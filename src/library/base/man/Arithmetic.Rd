% File src/library/base/man/Arithmetic.Rd
% Part of the R package, http://www.R-project.org
% Copyright 1995-2011 R Core Team
% Modifications for pqR Copyright (c) 2014, 2016, 2017, 2019, 2020 Radford M. Neal.
% Distributed under GPL 2 or later

\name{Arithmetic}
\title{Arithmetic Operators}
\usage{
x + y
x - y
x * y
x / y
x ^ y
x \%\% y
x \%/\% y
}
\alias{+}
\alias{-}
\alias{*}
\alias{**}
\alias{/}
\alias{^}
\alias{\%\%}
\alias{\%/\%}
\alias{Arithmetic}
\concept{remainder}
\concept{modulo}
\concept{modulus}
\concept{quotient}
\concept{division}
\description{
  These binary operators perform arithmetic on numeric or complex vectors
  (or objects which can be coerced to them). They can also be applied
  to lists, with the operation done recursively on elements.
}
\arguments{
  \item{x, y}{numeric or complex vectors or objects which can be
    coerced to such, or lists, or other objects for which methods have 
    been written.}
}
\details{
  These unary and binary arithmetic operators are generic functions: 
  methods can be written for them individually or via the
  \code{\link[=S3groupGeneric]{Ops}} group generic function.  (See
  \code{\link[=S3groupGeneric]{Ops}} for how dispatch is computed.)

  They can be applied to lists as described in \code{\link{Listops}}.

  If applied to arrays the result will be an array if this is sensible.

  Logical vectors will be coerced to integer or numeric vectors,
  \code{FALSE} having value zero and \code{TRUE} having value one.

  \code{1 ^ y} and \code{y ^ 0} are \code{1}, \emph{always}.
  \code{x ^ y} should also give the proper limit result when
  either argument is infinite (i.e., \code{+- \link{Inf}}).

  Objects such as arrays or time-series can be operated on this
  way provided they are conformable.

  For real arguments, \code{\%\%} can be subject to catastrophic loss of
  accuracy if \code{x} is much larger than \code{y}, and a warning is
  given if this is detected.

  \code{\%\%} and \code{x \%/\% y} can be used for non-integer \code{y},
  e.g. \code{1 \%/\% 0.2}, but the results are subject to representation
  error and so may be platform-dependent.  Because the IEC 60059
  representation of \code{0.2} is a binary fraction slightly larger than
  \code{0.2}, the answer to \code{1 \%/\% 0.2} should be \code{4} but
  most platforms give \code{5}.
  
  Users are sometimes surprised by the value returned, for example why
  \code{(-8)^(1/3)} is \code{NaN}.  For \link{double} inputs, \R makes
  use of IEC 60559 arithmetic on all platforms, together with the C
  system function \samp{pow} for the \code{^} operator.  The relevant
  standards define the result in many corner cases.  In particular, the
  result in the example above is mandated by the C99 standard.  On many
  Unix-alike systems the command \command{man pow} gives details of the
  values in a large number of corner cases.

  Arithmetic on type \link{double} in \R is supposed to be done in
  \sQuote{round to nearest, ties to even} mode, but this does depend on
  the compiler and FPU being set up correctly. 
}
\value{
  The default methods for these operators return vectors containing the 
  result of the element by element operations.  For the binary operators, 
  the elements of shorter vectors are recycled
  as necessary (with a \code{\link{warning}} when they are recycled only
  \emph{fractionally}).  

  The operators are \code{+} for addition,
  \code{-} for subtraction, \code{*} for multiplication, \code{/} for
  division and \code{^} for exponentiation.
  \code{\%\%} indicates \code{x mod y} and \code{\%/\%} indicates
  integer division.  It is guaranteed that \code{x == (x \%\% y) + y * (
  x \%/\% y )} (up to rounding error) unless \code{y == 0} where the
  result of \code{\%\%} is \code{\link{NA_integer_}} or
  \code{\link{NaN}} (depending on the \code{\link{typeof}} of the
  arguments).

  If either argument is complex the result will be complex, otherwise if
  one or both arguments are numeric, the result will be numeric.  If
  both arguments are of type \link{integer}, the type of the result of
  \code{/} and \code{^} is \link{numeric} and for the other operators it
  is integer (with overflow, which occurs at
  \eqn{\pm(2^{31} - 1)}{+/- (2^31 - 1)},
  returned as \code{NA_integer_} with a warning).

  Unary \code{+} and unary \code{-} return a numeric or complex vector.  All
  attributes (including class) are preserved if there is no
  coercion.  If \code{x} is logical, it is coerced to integer, and names, 
  dims, and dimnames (but not other attributes) are preserved.

  The rules for determining the attributes of the result for the binary
  operators are rather
  complicated.  Most attributes are taken from the longer argument, the
  first if they are of the same length.  Names will be copied from the
  first if it is the same length as the answer, otherwise from the
  second if that is.  For time series, these operations are allowed only
  if the series are compatible, when the class and \code{\link{tsp}}
  attribute of whichever is a time series (the same, if both are) are
  used.  For arrays (and an array result) the dimensions and dimnames
  are taken from first argument if it is an array, otherwise the second.
}
\section{S4 methods}{
  These operators are members of the S4 \code{\link{Arith}} group generic,
  and so methods can be written for them individually as well as for the
  group generic (or the \code{Ops} group generic), with arguments
  \code{c(e1, e2)}.
}
\section{Implementation limits}{
  pqR now requires that floating-point arithmetic conform to the
  IEC 60559 (also known as IEEE 754) standard, and will complain and
  refuse to start if it detects that this is not so.  This includes
  support for \emph{denormalized numbers}
  (non-zero numbers closer to zero than \code{.Machine$double.xmin}).

  Another potential issue is signed zeroes: IEC 60659 includes
  two zeroes with internal representations differing by sign.  Where
  possible \R treats them as the same, but for example direct output
  from C code often does not do so and may output \samp{-0.0} (and on
  Windows whether it does so or not depends on the version of Windows).
  One place in \R where the difference might be seen is in division by
  zero: \code{1/x} is \code{Inf} or \code{-Inf} depending on the sign of
  zero \code{x}.

  Operations where one operand is \code{NA} or \code{NaN} and the
  other is a non-special number will return the \code{NA} or
  \code{NaN} operand as their result.  This is also the case when both
  operands are \code{NA}, or both are \code{NaN}.  When one operand is
  \code{NA} and the other is \code{NaN}, the result will be either
  \code{NA} or \code{NaN}, but which is arbitrary: it may vary from
  one system to another, or when pqR is compiled on the same system
  with different compilers, or when the operation is done in different
  contexts (eg, as a scalar or vector).  It might even vary randomly.
}
\note{
  \code{**} is accepted as a synonym for \code{^}, referring to the
  same primitive operator.  This was undocumented for many years, 
  in both S and R.  It appears as an index entry in Becker
  \emph{et al} (1988), pointing to the help for \code{Deprecated} but
  is not actually mentioned on that page.  
}
\references{
  Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988)
  \emph{The New S Language}.
  Wadsworth & Brooks/Cole.

  D. Goldberg (1991) \emph{What Every Computer Scientist Should Know
    about Floating-Point Arithmetic}  ACM Computing Surveys, \bold{23(1)}.\cr
  Postscript version available at
  \url{http://www.validlab.com/goldberg/paper.ps}
  Extended PDF version at \url{http://www.validlab.com/goldberg/paper.pdf}

}
\seealso{
  \code{\link{sqrt}} for miscellaneous and \code{\link{Special}} for special
  mathematical functions.

  \code{\link{Syntax}} for operator precedence.

  \code{\link{\%*\%}} for matrix multiplication.
}
\examples{
x <- -1:12
x + 1
2 * x + 3
x \%\% 2 #-- is periodic
x \%/\% 5
}
\keyword{arith}
